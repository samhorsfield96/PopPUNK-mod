#!/usr/bin/env python
# vim: set fileencoding=<utf-8> :
# Copyright 2024 John Lees, Nick Croucher and Samuel Horsfield

import pickle
import sys, os
import numpy as np
import argparse
import matplotlib.pyplot as plt
from run_elfi import negative_exponential

# command line parsing
def get_options():

    parser = argparse.ArgumentParser(description='Extract tab-separated file of distances from pkl and npy files', prog='python extract_poppunk_distances.py')

    # input options
    parser.add_argument('--distances', help='Path to .dists prefix generated by PopPUNK (required)',
                                    required=True)
    parser.add_argument('--total', help='Number of distances to return. Default = 100000',
                                    type=int,
                                    default=100000)
    parser.add_argument('--outpref', help='Output prefix (required)',
                                    required = True)

    return parser.parse_args()

def listDistInts(refSeqs, querySeqs, self=True):
    """Gets the ref and query ID for each row of the distance matrix

    Returns an iterable with ref and query ID pairs by row.

    Args:
        refSeqs (list)
            List of reference sequence names.
        querySeqs (list)
            List of query sequence names.
        self (bool)
            Whether a self-comparison, used when constructing a database.
            Requires refSeqs == querySeqs
            Default is True
    Returns:
        ref, query (str, str)
            Iterable of tuples with ref and query names for each distMat row.
    """
    num_ref = len(refSeqs)
    num_query = len(querySeqs)
    if self:
        if refSeqs != querySeqs:
            raise RuntimeError('refSeqs must equal querySeqs for db building (self = true)')
        for i in range(num_ref):
            for j in range(i + 1, num_ref):
                yield(j, i)
    else:
        comparisons = [(0,0)] * (len(refSeqs) * len(querySeqs))
        for i in range(num_query):
            for j in range(num_ref):
                yield(j, i)

def isolateNameToLabel(names):
    """Function to process isolate names to labels
    appropriate for visualisation.

    Args:
        names (list)
            List of isolate names.
    Returns:
        labels (list)
            List of isolate labels.
    """
    # useful to have as a function in case we
    # want to remove certain characters
    labels = [os.path.splitext(os.path.basename(name))[0] for name in names]
    return labels

# main code
if __name__ == "__main__":

    # Check input ok
    args = get_options()

    # open stored distances
    with open(args.distances + ".pkl", 'rb') as pickle_file:
        rlist, qlist, self = pickle.load(pickle_file)

    # get names order
    r_names = isolateNameToLabel(rlist)

    # write output
    with open(args.outpref + "_samples.txt", 'w') as oFile:   
        for name in r_names:
            oFile.write(name + "\n")

    # Load matrix
    X = np.load(args.distances + ".npy")
    #print(X)
    num_rows, num_cols = X.shape

    #randomly generate indices to sample from
    samples_index = np.random.choice(num_rows, size=args.total, replace=False)

    # sample from array
    X_sample = X[samples_index]
    #print(X_sample)

    # open output file
    with open(args.outpref + "_distances.tsv", 'w') as oFile:
        # Write distances
        for i in range(X_sample.shape[0]):
            oFile.write("\t".join([str(X_sample[i,0]), str(X_sample[i,1])]))
            oFile.write("\n")

    # plot fit
    fig, ax = plt.subplots()
    ax.scatter(X_sample[:,0], X_sample[:,1], s=10, alpha=0.2)
    # try negative exponential fit
    try:
        x_fit = np.linspace(0, X_sample[:,0].max(), 100)
        y_fit = negative_exponential(x_fit, *popt)
        ax.plot(x_fit, y_fit, label=f"Negative exponential 3 param", color='red')

        xlim = ax.get_xlim()
        ylim = ax.get_ylim()
        x_annotate = 0.5 * xlim[1]  # 50% of the x-axis range
        y_annotate = 0.1 * ylim[1]  # 10% of the y-axis range

        # Calculate the initial rate at x=0
        print("Negative exponential 3 param, b0: {}, b1: {}, b2: {}".format(b0, b1, b2))

        ax.annotate("b0: {}, b1: {},\nb2: {}".format(round(b0, 3), round(b1, 3), round(b2, 3)), xy=(0, 0), xytext=(x_annotate, y_annotate),
                fontsize=10, color="green")
    except:
        pass

    ax.set_xlabel("Core distance")
    ax.set_ylabel("Accessory distance")

    fig.savefig(args.outpref + "_curve_fit.png")
    plt.close()